
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "content/examples/05-fdem/plot_inv_fdem_loop_loop_2Dinversion.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_content_examples_05-fdem_plot_inv_fdem_loop_loop_2Dinversion.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_content_examples_05-fdem_plot_inv_fdem_loop_loop_2Dinversion.py:


2D inversion of Loop-Loop EM Data
=================================

In this example, we consider a single line of loop-loop EM data
at 30kHz with 3 different coil separations [0.32m, 0.71m, 1.18m].
We will use only Horizontal co-planar orientations (vertical magnetic dipole),
and look at the real and imaginary parts of the secondary magnetic field.

We use the :class:`SimPEG.maps.Surject2Dto3D` mapping to invert for a 2D model
and perform the forward modelling in 3D.

.. GENERATED FROM PYTHON SOURCE LINES 14-37

.. code-block:: default


    import numpy as np
    import matplotlib.pyplot as plt
    import time

    try:
        from pymatsolver import Pardiso as Solver
    except ImportError:
        from SimPEG import SolverLU as Solver

    import discretize
    from SimPEG import (
        maps,
        optimization,
        data_misfit,
        regularization,
        inverse_problem,
        inversion,
        directives,
        Report,
    )
    from SimPEG.electromagnetics import frequency_domain as FDEM








.. GENERATED FROM PYTHON SOURCE LINES 38-43

Setup
-----

Define the survey and model parameters


.. GENERATED FROM PYTHON SOURCE LINES 43-54

.. code-block:: default


    sigma_surface = 10e-3
    sigma_deep = 40e-3
    sigma_air = 1e-8

    coil_separations = [0.32, 0.71, 1.18]
    freq = 30e3

    print("skin_depth: {:1.2f}m".format(500 / np.sqrt(sigma_deep * freq)))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    skin_depth: 14.43m




.. GENERATED FROM PYTHON SOURCE LINES 55-57

Define a dipping interface between the surface layer and the deeper layer


.. GENERATED FROM PYTHON SOURCE LINES 58-80

.. code-block:: default


    z_interface_shallow = -0.25
    z_interface_deep = -1.5
    x_dip = np.r_[0.0, 8.0]


    def interface(x):
        interface = np.zeros_like(x)

        interface[x < x_dip[0]] = z_interface_shallow

        dipping_unit = (x >= x_dip[0]) & (x <= x_dip[1])
        x_dipping = (-(z_interface_shallow - z_interface_deep) / x_dip[1]) * (
            x[dipping_unit]
        ) + z_interface_shallow
        interface[dipping_unit] = x_dipping

        interface[x > x_dip[1]] = z_interface_deep

        return interface









.. GENERATED FROM PYTHON SOURCE LINES 81-91

Forward Modelling Mesh
----------------------

Here, we set up a 3D tensor mesh which we will perform the forward
simulations on.

.. note::

  In practice, a smaller horizontal discretization should be used to improve
  accuracy, particularly for the shortest offset (eg. you can try 0.25m).

.. GENERATED FROM PYTHON SOURCE LINES 91-123

.. code-block:: default


    csx = 0.5  # cell size for the horizontal direction
    csz = 0.125  # cell size for the vertical direction
    pf = 1.3  # expansion factor for the padding cells

    npadx = 7  # number of padding cells in the x-direction
    npady = 7  # number of padding cells in the y-direction
    npadz = 11  # number of padding cells in the z-direction

    core_domain_x = np.r_[-11.5, 11.5]  # extent of uniform cells in the x-direction
    core_domain_z = np.r_[-2.0, 0.0]  # extent of uniform cells in the z-direction

    # number of cells in the core region
    ncx = int(np.diff(core_domain_x) / csx)
    ncz = int(np.diff(core_domain_z) / csz)

    # create a 3D tensor mesh
    mesh = discretize.TensorMesh(
        [
            [(csx, npadx, -pf), (csx, ncx), (csx, npadx, pf)],
            [(csx, npady, -pf), (csx, 1), (csx, npady, pf)],
            [(csz, npadz, -pf), (csz, ncz), (csz, npadz, pf)],
        ]
    )
    # set the origin
    mesh.x0 = np.r_[
        -mesh.hx.sum() / 2.0, -mesh.hy.sum() / 2.0, -mesh.hz[: npadz + ncz].sum()
    ]

    print("the mesh has {} cells".format(mesh.nC))
    mesh.plotGrid()




.. image:: /content/examples/05-fdem/images/sphx_glr_plot_inv_fdem_loop_loop_2Dinversion_001.png
    :alt: plot inv fdem loop loop 2Dinversion
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    the mesh has 34200 cells

    <Axes3DSubplot:xlabel='x1', ylabel='x2'>



.. GENERATED FROM PYTHON SOURCE LINES 124-129

Inversion Mesh
--------------

Here, we set up a 2D tensor mesh which we will represent the inversion model
on

.. GENERATED FROM PYTHON SOURCE LINES 129-134

.. code-block:: default


    inversion_mesh = discretize.TensorMesh([mesh.hx, mesh.hz[mesh.vectorCCz <= 0]])
    inversion_mesh.x0 = [-inversion_mesh.hx.sum() / 2.0, -inversion_mesh.hy.sum()]
    inversion_mesh.plotGrid()




.. image:: /content/examples/05-fdem/images/sphx_glr_plot_inv_fdem_loop_loop_2Dinversion_002.png
    :alt: plot inv fdem loop loop 2Dinversion
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    <AxesSubplot:xlabel='x1', ylabel='x2'>



.. GENERATED FROM PYTHON SOURCE LINES 135-141

Mappings
---------

Mappings are used to take the inversion model and represent it as electrical
conductivity on the inversion mesh. We will invert for log-conductivity below
the surface, fixing the conductivity of the air cells to 1e-8 S/m

.. GENERATED FROM PYTHON SOURCE LINES 141-157

.. code-block:: default


    # create a 2D mesh that includes air cells
    mesh2D = discretize.TensorMesh([mesh.hx, mesh.hz], x0=mesh.x0[[0, 2]])
    active_inds = mesh2D.gridCC[:, 1] < 0  # active indices are below the surface


    mapping = (
        maps.Surject2Dto3D(mesh)
        * maps.InjectActiveCells(  # populates 3D space from a 2D model
            mesh2D, active_inds, sigma_air
        )
        * maps.ExpMap(  # adds air cells
            nP=inversion_mesh.nC
        )  # takes the exponential (log(sigma) --> sigma)
    )








.. GENERATED FROM PYTHON SOURCE LINES 158-162

True Model
----------

Create our true model which we will use to generate synthetic data for

.. GENERATED FROM PYTHON SOURCE LINES 162-174

.. code-block:: default


    m_true = np.log(sigma_deep) * np.ones(inversion_mesh.nC)
    interface_depth = interface(inversion_mesh.gridCC[:, 0])
    m_true[inversion_mesh.gridCC[:, 1] > interface_depth] = np.log(sigma_surface)

    fig, ax = plt.subplots(1, 1)
    cb = plt.colorbar(inversion_mesh.plotImage(m_true, ax=ax, grid=True)[0], ax=ax)
    cb.set_label("$\log(\sigma)$")
    ax.set_title("true model")
    ax.set_xlim([-10, 10])
    ax.set_ylim([-2, 0])




.. image:: /content/examples/05-fdem/images/sphx_glr_plot_inv_fdem_loop_loop_2Dinversion_003.png
    :alt: true model
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    (-2.0, 0.0)



.. GENERATED FROM PYTHON SOURCE LINES 175-179

Survey
------

Create our true model which we will use to generate synthetic data for

.. GENERATED FROM PYTHON SOURCE LINES 179-215

.. code-block:: default


    src_locations = np.arange(-11, 11, 0.5)
    src_z = 0.25  # src is 0.25m above the surface
    orientation = "z"  # z-oriented dipole for horizontal co-planar loops

    # reciever offset in 3D space
    rx_offsets = np.vstack([np.r_[sep, 0.0, 0.0] for sep in coil_separations])

    # create our source list - one source per location
    srcList = []
    for x in src_locations:
        src_loc = np.r_[x, 0.0, src_z]
        rx_locs = src_loc - rx_offsets

        rx_real = FDEM.Rx.PointMagneticFluxDensitySecondary(
            locations=rx_locs, orientation=orientation, component="real"
        )
        rx_imag = FDEM.Rx.PointMagneticFluxDensitySecondary(
            locations=rx_locs, orientation=orientation, component="imag"
        )

        src = FDEM.Src.MagDipole(
            receiver_list=[rx_real, rx_imag],
            loc=src_loc,
            orientation=orientation,
            freq=freq,
        )

        srcList.append(src)

    # create the survey and problem objects for running the forward simulation
    survey = FDEM.Survey(srcList)
    prob = FDEM.Simulation3DMagneticFluxDensity(
        mesh, survey=survey, sigmaMap=mapping, Solver=Solver
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/vsts/work/1/s/SimPEG/utils/code_utils.py:413: FutureWarning:

    loc has been deprecated, please use location. It will be removed in version 0.16.0 of SimPEG.

    /home/vsts/work/1/s/SimPEG/utils/code_utils.py:420: FutureWarning:

    loc has been deprecated, please use location. It will be removed in version 0.16.0 of SimPEG.

    /home/vsts/work/1/s/SimPEG/utils/code_utils.py:413: FutureWarning:

    freq has been deprecated, please use frequency. It will be removed in version 0.16.0 of SimPEG.

    /home/vsts/work/1/s/SimPEG/utils/code_utils.py:420: FutureWarning:

    freq has been deprecated, please use frequency. It will be removed in version 0.16.0 of SimPEG.

    /home/vsts/work/1/s/SimPEG/utils/code_utils.py:413: FutureWarning:

    Solver has been deprecated, please use simulation.solver. It will be removed in version 0.16.0 of SimPEG.

    /home/vsts/work/1/s/SimPEG/utils/code_utils.py:420: FutureWarning:

    Solver has been deprecated, please use simulation.solver. It will be removed in version 0.16.0 of SimPEG.





.. GENERATED FROM PYTHON SOURCE LINES 216-221

Set up data for inversion
-------------------------

Generate clean, synthetic data. Later we will invert the clean data, and
assign a standard deviation of 0.05, and a floor of 1e-11.

.. GENERATED FROM PYTHON SOURCE LINES 221-269

.. code-block:: default


    t = time.time()

    data = prob.make_synthetic_data(
        m_true, relative_error=0.05, noise_floor=1e-11, add_noise=False
    )

    dclean = data.dclean
    print("Done forward simulation. Elapsed time = {:1.2f} s".format(time.time() - t))


    def plot_data(data, ax=None, color="C0", label=""):
        if ax is None:
            fig, ax = plt.subplots(1, 3, figsize=(15, 5))

        # data is [re, im, re, im, ...]
        data_real = data[0::2]
        data_imag = data[1::2]

        for i, offset in enumerate(coil_separations):
            ax[i].plot(
                src_locations,
                data_real[i :: len(coil_separations)],
                color=color,
                label="{} real".format(label),
            )
            ax[i].plot(
                src_locations,
                data_imag[i :: len(coil_separations)],
                "--",
                color=color,
                label="{} imag".format(label),
            )

            ax[i].set_title("offset = {:1.2f}m".format(offset))
            ax[i].legend()
            ax[i].grid(which="both")
            ax[i].set_ylim(np.r_[data.min(), data.max()] + 1e-11 * np.r_[-1, 1])

            ax[i].set_xlabel("source location x (m)")
            ax[i].set_ylabel("Secondary B-Field (T)")

        plt.tight_layout()
        return ax


    ax = plot_data(dclean)




.. image:: /content/examples/05-fdem/images/sphx_glr_plot_inv_fdem_loop_loop_2Dinversion_004.png
    :alt: offset = 0.32m, offset = 0.71m, offset = 1.18m
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Done forward simulation. Elapsed time = 19.63 s




.. GENERATED FROM PYTHON SOURCE LINES 270-285

Set up the inversion
--------------------

We create the data misfit, simple regularization
(a Tikhonov-style regularization, :class:`SimPEG.regularization.Simple`)
The smoothness and smallness contributions can be set by including
`alpha_s, alpha_x, alpha_y` as input arguments when the regularization is
created. The default reference model in the regularization is the starting
model. To set something different, you can input an `mref` into the
regularization.

We estimate the trade-off parameter, beta, between the data
misfit and regularization by the largest eigenvalue of the data misfit and
the regularization. Here, we use a fixed beta, but could alternatively
employ a beta-cooling schedule using :class:`SimPEG.directives.BetaSchedule`

.. GENERATED FROM PYTHON SOURCE LINES 285-299

.. code-block:: default


    dmisfit = data_misfit.L2DataMisfit(simulation=prob, data=data)
    reg = regularization.Simple(inversion_mesh)
    opt = optimization.InexactGaussNewton(maxIterCG=10, remember="xc")
    invProb = inverse_problem.BaseInvProblem(dmisfit, reg, opt)

    betaest = directives.BetaEstimate_ByEig(beta0_ratio=0.05, n_pw_iter=1, seed=1)
    target = directives.TargetMisfit()

    directiveList = [betaest, target]
    inv = inversion.BaseInversion(invProb, directiveList=directiveList)

    print("The target misfit is {:1.2f}".format(target.target))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The target misfit is 132.00




.. GENERATED FROM PYTHON SOURCE LINES 300-304

Run the inversion
------------------

We start from a half-space equal to the deep conductivity.

.. GENERATED FROM PYTHON SOURCE LINES 304-311

.. code-block:: default


    m0 = np.log(sigma_deep) * np.ones(inversion_mesh.nC)

    t = time.time()
    mrec = inv.run(m0)
    print("\n Inversion Complete. Elapsed Time = {:1.2f} s".format(time.time() - t))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    SimPEG.InvProblem will set Regularization.mref to m0.

            SimPEG.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.
            ***Done using same Solver and solverOpts as the problem***
    model has any nan: 0
    ============================ Inexact Gauss Newton ============================
      #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   
    -----------------------------------------------------------------------------
    x0 has any nan: 0
       0  5.15e+00  7.10e+03  0.00e+00  7.10e+03    1.60e+03      0              
       1  5.15e+00  8.52e+02  3.77e+01  1.05e+03    2.18e+02      0              
       2  5.15e+00  1.36e+02  8.46e+01  5.72e+02    1.96e+01      0   Skip BFGS  
       3  5.15e+00  1.42e+02  8.20e+01  5.65e+02    1.97e+01      0              
       4  5.15e+00  1.33e+02  8.34e+01  5.63e+02    1.28e+01      0              
       5  5.15e+00  1.34e+02  8.20e+01  5.57e+02    6.64e+00      1              
    ------------------------- STOP! -------------------------
    1 : |fc-fOld| = 0.0000e+00 <= tolF*(1+|f0|) = 7.0960e+02
    1 : |xc-x_last| = 2.8363e-01 <= tolX*(1+|x0|) = 1.3056e+01
    0 : |proj(x-g)-x|    = 6.6419e+00 <= tolG          = 1.0000e-01
    0 : |proj(x-g)-x|    = 6.6419e+00 <= 1e3*eps       = 1.0000e-02
    0 : maxIter   =      20    <= iter          =      6
    ------------------------- DONE! -------------------------

     Inversion Complete. Elapsed Time = 1193.75 s




.. GENERATED FROM PYTHON SOURCE LINES 312-315

Plot the predicted and observed data
------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 315-320

.. code-block:: default


    fig, ax = plt.subplots(1, 3, figsize=(15, 5))
    plot_data(dclean, ax=ax, color="C0", label="true")
    plot_data(invProb.dpred, ax=ax, color="C1", label="predicted")




.. image:: /content/examples/05-fdem/images/sphx_glr_plot_inv_fdem_loop_loop_2Dinversion_005.png
    :alt: offset = 0.32m, offset = 0.71m, offset = 1.18m
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    array([<AxesSubplot:title={'center':'offset = 0.32m'}, xlabel='source location x (m)', ylabel='Secondary B-Field (T)'>,
           <AxesSubplot:title={'center':'offset = 0.71m'}, xlabel='source location x (m)', ylabel='Secondary B-Field (T)'>,
           <AxesSubplot:title={'center':'offset = 1.18m'}, xlabel='source location x (m)', ylabel='Secondary B-Field (T)'>],
          dtype=object)



.. GENERATED FROM PYTHON SOURCE LINES 321-324

Plot the recovered model
------------------------


.. GENERATED FROM PYTHON SOURCE LINES 324-350

.. code-block:: default


    fig, ax = plt.subplots(1, 2, figsize=(12, 5))

    # put both plots on the same colorbar
    clim = np.r_[np.log(sigma_surface), np.log(sigma_deep)]

    # recovered model
    cb = plt.colorbar(inversion_mesh.plotImage(mrec, ax=ax[0], clim=clim)[0], ax=ax[0],)
    ax[0].set_title("recovered model")
    cb.set_label("$\log(\sigma)$")

    # true model
    cb = plt.colorbar(inversion_mesh.plotImage(m_true, ax=ax[1], clim=clim)[0], ax=ax[1],)
    ax[1].set_title("true model")
    cb.set_label("$\log(\sigma)$")

    # # uncomment to plot the true interface
    # x = np.linspace(-10, 10, 50)
    # [a.plot(x, interface(x), 'k') for a in ax]

    [a.set_xlim([-10, 10]) for a in ax]
    [a.set_ylim([-2, 0]) for a in ax]

    plt.tight_layout()
    plt.show()




.. image:: /content/examples/05-fdem/images/sphx_glr_plot_inv_fdem_loop_loop_2Dinversion_006.png
    :alt: recovered model, true model
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 351-354

Print the version of SimPEG and dependencies
--------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 354-357

.. code-block:: default


    Report()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table style='border: 3px solid #ddd;'>
      <tr>
         <td style='text-align: center; font-weight: bold; font-size: 1.2em; border: 2px solid #fff;' colspan='6'>Sat Aug 28 02:33:57 2021 UTC</td>
      </tr>
      <tr>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>OS</td>
        <td style='text-align: left; border: 2px solid #fff;'>Linux</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>CPU(s)</td>
        <td style='text-align: left; border: 2px solid #fff;'>2</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Machine</td>
        <td style='text-align: left; border: 2px solid #fff;'>x86_64</td>
      </tr>
      <tr>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Architecture</td>
        <td style='text-align: left; border: 2px solid #fff;'>64bit</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>RAM</td>
        <td style='text-align: left; border: 2px solid #fff;'>6.8 GiB</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Environment</td>
        <td style='text-align: left; border: 2px solid #fff;'>Python</td>
      </tr>
      <tr>
         <td style='text-align: center; border: 2px solid #fff;' colspan='6'>Python 3.7.11 (default, Jul 27 2021, 14:32:16) 
    [GCC 7.5.0]</td>
      </tr>
      <tr>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>SimPEG</td>
        <td style='text-align: left; border: 2px solid #fff;'>0.15.1</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>discretize</td>
        <td style='text-align: left; border: 2px solid #fff;'>0.7.0</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>pymatsolver</td>
        <td style='text-align: left; border: 2px solid #fff;'>0.1.3</td>
      </tr>
      <tr>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>vectormath</td>
        <td style='text-align: left; border: 2px solid #fff;'>0.2.2</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>properties</td>
        <td style='text-align: left; border: 2px solid #fff;'>0.6.1</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>numpy</td>
        <td style='text-align: left; border: 2px solid #fff;'>1.20.3</td>
      </tr>
      <tr>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>scipy</td>
        <td style='text-align: left; border: 2px solid #fff;'>1.6.2</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>cython</td>
        <td style='text-align: left; border: 2px solid #fff;'>0.29.24</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>IPython</td>
        <td style='text-align: left; border: 2px solid #fff;'>7.26.0</td>
      </tr>
      <tr>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>matplotlib</td>
        <td style='text-align: left; border: 2px solid #fff;'>3.4.2</td>
        <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>ipywidgets</td>
        <td style='text-align: left; border: 2px solid #fff;'>7.6.3</td>
        <td style= border: 2px solid #fff;'></td>
        <td style= border: 2px solid #fff;'></td>
      </tr>
      <tr>
         <td style='text-align: center; background-color: #ddd;border: 2px solid #fff;' colspan='6'>Intel(R) oneAPI Math Kernel Library Version 2021.3-Product Build 20210617 for Intel(R) 64 architecture applications</td>
      </tr>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 358-369

Moving Forward
--------------

If you have suggestions for improving this example, please create a `pull request on the example in SimPEG <https://github.com/simpeg/simpeg/blob/main/examples/07-fdem/plot_loop_loop_2Dinversion.py>`_

You might try:
   - improving the discretization
   - changing beta
   - changing the noise model
   - playing with the regulariztion parameters
   - ...


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 20 minutes  20.528 seconds)

**Estimated memory usage:**  1658 MB


.. _sphx_glr_download_content_examples_05-fdem_plot_inv_fdem_loop_loop_2Dinversion.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_inv_fdem_loop_loop_2Dinversion.py <plot_inv_fdem_loop_loop_2Dinversion.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_inv_fdem_loop_loop_2Dinversion.ipynb <plot_inv_fdem_loop_loop_2Dinversion.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
